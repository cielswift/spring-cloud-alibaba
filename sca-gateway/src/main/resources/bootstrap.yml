server:
  port: 5210
  servlet:
    context-path: /gateway
spring:
  application:
    name: gateway
  redis: #redis
    host: 127.0.0.1
    port: 6510
    password: ciel
    database: 2
  aop:
    proxy-target-class: true #使用cglib代理
  main:
    allow-bean-definition-overriding: true #bean冲突覆盖
  profiles:
    active: dev #开发模式
  cloud:
    nacos:  #使用nacos注册中心
      discovery:
        server-addr: 127.0.0.1:13100,127.0.0.1:13101,127.0.0.1:13102
        namespace: a998603d-3546-4ddc-9099-2ed82a6f3a68 #开发环境
        group: DEFAULT_GROUP #组
      config:
        server-addr: 127.0.0.1:13100,127.0.0.1:13101,127.0.0.1:13102
        file-extension: yaml  #指定读取的配置文件后缀, dataId 默认就是spring.application.name + yaml, 可以通过prefix修改
        namespace: a998603d-3546-4ddc-9099-2ed82a6f3a68 #开发环境
        group: DEFAULT_GROUP #组
        prefix: gateway #文件名 -- 如果没有配置则默认为 ${spring.appliction.name} (优先级高)
        extension-configs:  #扩展配置,多个配置文件
          - dataId: xiapeixin.yaml
            group: DEFAULT_GROUP
            refresh: false
          - dataId: xiapeixin2.yaml
            group: DEFAULT_GROUP
            refresh: false

    gateway:  #路由规则
#      globalcors: #跨域设置
#        corsConfigurations:
#          '[/**]':
#            allow-credentials: true
#            allowedHeaders: "*"
#            allowedOrigins: "*"
#            allowedMethods:
#              - GET
#                POST
#                DELETE
#                PUT
#                OPTION
#            max-age: 3600
      discovery:
        locator:
          enabled: true  #开启根据服务名称进行转发
          lower-case-service-id: true #微服务名称小写
#      routes:
#        - id: consumer #id 任意
#          uri: lb://consumer
#          predicates:
#            - Path=/con/** #请求路径带有这个,那么映射到上面uri的服务上
#            #- Before=2019-05-13T17:20:10.789-07:00[Asia/Shanghai] #并且要在这个时间之前
#            - After=2019-02-14T13:10:47.789-07:00[Asia/Shanghai]
#            #- Header=X-Request-Id, \d+ #有请求头名为 x-request-id，其值与 \d+ 正则表达式匹配（值为一个或多个数字），则此路由匹配
#          filters:
#            - StripPrefix=1 #访问路径 http://127.0.0.1:5210/gateway/con/consumer/d1?name=xia
#            - name: RequestRateLimiter #请求数限流 名字不能随便写
#              args:
#                key-resolver: "#{@ipKeyResolver}"  #获取刚才创建的对象
#                redis-rate-limiter.replenishRate: 1  #令牌桶每秒填充平均速率
#                redis-rate-limiter.burstCapacity: 1  #令牌桶总容量

#        - burstCapacity：令牌桶总容量。
#        - replenishRate：令牌桶每秒填充平均速率。
#        - key-resolver：用于限流的键的解析器的 Bean 对象的名字。它使用 SpEL 表达式根据#{@beanName}从 Spring 容器中获取 Bean 对象。
#
#      通过在replenishRate和中设置相同的值来实现稳定的速率burstCapacity。设置burstCapacity高于时，可以允许临时突发replenishRate。
#      在这种情况下，需要在突发之间允许速率限制器一段时间（根据replenishRate），因为2次连续突发将导致请求被丢弃（HTTP 429 - Too Many Requests）
#      key-resolver: "#{@userKeyResolver}" 用于通过SPEL表达式来指定使用哪一个KeyResolver.
#      如上配置：
#      表示 一秒内，允许 一个请求通过，令牌桶的填充速率也是一秒钟添加一个令牌。
#      最大突发状况 也只允许 一秒内有一次请求，可以根据业务来调整 。

#    loadbalancer:
#      retry:
#        enabled: true #该参数用来开启重试机制
    sentinel: #限流
      transport:
        dashboard: 127.0.0.1:8080

  zipkin:  #链路追踪
    base-url: http://127.0.0.1:9411/
  sleuth:
    sampler:
      probability: 1 #percentage是采样比例

ribbon:
  ReadTimeout: 5000
  ConnectTimeout: 5000

management:
  endpoints:
    web:
      exposure:
        include: '*'

logging:
  config: classpath:logback-spring.xml

---
custom-mod:  #多文档模式,定义一些其他配置
  name: gateway

spring:
  profiles:
    active: dev